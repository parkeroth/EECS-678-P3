"""
:mod:`nachosfilters` -- Nachos Filters for KUSP DSPP
=====================================================
    :synopsis: Nachos Filters for KUSP Data Streams Post Processing

.. moduleauthor:: Dillon Hicks <hhicks@ittc.ku.edu>
"""
from datastreams.postprocess import filtering, entities
from datastreams.postprocess.filters.input_output import pickle
from datastreams.postprocess.entities import TimeMeasurement
import cPickle
import pprint

class NachosTime(TimeMeasurement):
    """
    NachosTime is a specific case of the Data Streams Post Processing
    TimeMeasurement class.

    The specificity to Nachos is NachosTime is always measured in
    Ticks, it is generated by Nachos, and because of the nature of
    Nachos, there is not any error associated with it.
    """
    def __init__(self, value):
        #  Units | Value | Generated By | Lower Error | High Error
        TimeMeasurement.__init__(self, 'tsc', value, 'Nachos', 0, 0)


class CalculateThreadIntervalsFilter(filtering.Filter):
    """
    NACHOS POST PROCESSING PIPELINE: STAGE 0

    As the name suggests, this filter calculates activity and
    inactivity intervals on a per thread basis from Nachos DSUI
    events. The calculated intervals are then sent back into the
    pipeline again for active-state segregation and histogram creation. 
    
    """

    def initialize(self):
        """
        Name Space Pointer Reference:
        
        Pointer               |  DSTRM Instrumentation Location
        ---------------------------------------------------
        switch_to_ptr            thread/scheduler.cc
        switch_from_ptr          thread/scheduler.cc
        reached_exit_ptr         thread/thread.cc
        activity_period_ptr      Generated By This Filter
        inactivity_period_ptr    Generated By This Filter
        machine_run_ptr          machine/mipsim.cc
        thread_constructor_prt   thread/thread.cc
        """
        self.switch_to_ptr = self.get_ns_pointer("SCHED/SWITCH_TO")
        self.switch_from_ptr = self.get_ns_pointer("SCHED/SWITCH_FROM")
        self.reached_exit_ptr = self.get_ns_pointer("THREAD/REACHED_EXIT")
        self.activity_period_ptr = self.get_ns_pointer("THREAD_ACTIVITY/ACTIVITY_PERIOD")
        self.inactivity_period_ptr = self.get_ns_pointer("THREAD_ACTIVITY/INACTIVITY_PERIOD")
        self.machine_run_ptr = self.get_ns_pointer("MACHINE/RUN")
        self.thread_constructor_ptr = self.get_ns_pointer("THREAD/CLASS_CONSTRUCTOR")
        self.all_thread_ptrs = [ 
                                self.switch_to_ptr,
                                self.switch_from_ptr,
                                self.reached_exit_ptr,
                                self.activity_period_ptr,
                                self.inactivity_period_ptr,
                                self.machine_run_ptr,
                                self.thread_constructor_ptr,
                                ]

        self.lastswitch = None #for activity periods
        self.inactives = {} #inactivity periods
        self.hasExited = {}
        self.nachos_time = 0
        
    
    def process(self, entity):
        """
        The first stage of Post Processesing the NACHOS DSUI
        events. Here the active and inactive intervals for each thread
        are calculated from the DSUI events and placed back into the
        processing pipeline. Currently, they are further processed
        from active and inactive intervals into a sum of activity and
        inactivity periods for each threads by
        ProcessThreadActivityPeriods.
        """

        cid = entity.get_cid()
        
        # If the cid does not match any of the pointers' cid in the
        # all_thread_ptrs list.
        if not any(cid == ptr.get_cid() for ptr in self.all_thread_ptrs):
            # Then, pass the event back to the pipeline and exit the
            # function since it is not a pointer that is handled by
            # the filter.
            self.send(entity)
            return 

        # All of the events processed by this filter have the Nachos
        # timer ticks at the time the event was created as extra
        # data. So update teh current nachos_time with the event's
        # timer ticks data.
        self.nachos_time = entity.get_extra_data()

        # The thread's pid is the tag in the data stream event.
        thread_pid = entity.get_tag()
        if thread_pid not in self.inactives:
            # fill in entry for this pid
            self.inactives[thread_pid] = {'last':None}
            

        # We want to mask execution intervals after a thread has
        # reached the THREAD/EXIT event
        #
        if thread_pid not in self.hasExited:
            # fill in entry for this pid
            self.hasExited[thread_pid] = False

        # inactivity intervals are from the last thread creation event or
        # switch from event to the next machine::run event or switch to event 
        #
        if cid == self.switch_to_ptr.get_cid() or cid == self.machine_run_ptr.get_cid():
            # record timestamp for activity period tracking
            self.lastswitch = self.nachos_time

            last_tsc = self.inactives[thread_pid]['last']
            if last_tsc and not self.hasExited[thread_pid]:
                inactive_interval = entities.Interval(self.inactivity_period_ptr.get_cid(), 
                                                      { 'tsc' : NachosTime(last_tsc) }, 
                                                      { 'tsc' : NachosTime(self.nachos_time) }, 
                                                      entity.get_tag())
                self.send(inactive_interval)
            
            

        # activity intervals are from the last switch to event to the next
        # switch from event
        #
        if cid == self.switch_from_ptr.get_cid():
            # note switch from for inactivity calculation
            self.inactives[thread_pid]['last'] = self.nachos_time

            if self.lastswitch:
                active_interval = entities.Interval(self.activity_period_ptr.get_cid(),
                                                    { 'tsc' : NachosTime(self.lastswitch) }, 
                                                    { 'tsc' : NachosTime(self.nachos_time) }, 
                                                    entity.get_tag())
                self.lastswitch = None
                self.send(active_interval)
                
            

        # Mark when a thread has exited so inactivity intervals after a thread
        # has exited are not tabulated 
        if cid == self.reached_exit_ptr.get_cid():
            self.hasExited[thread_pid] = True
            entity = entity.change_tag([self.nachos_time])
        
        # Thread class construction is noted to start inactivity periods
        if cid == self.thread_constructor_ptr.get_cid():
            self.inactives[thread_pid]['last'] = self.nachos_time



class ThreadStateIntervalFilter(filtering.Filter):
    """
    NACHOS POST PROCESSING PIPELINE: STAGE 1

    Filters the active and inactive intervals produced by Stage 0 of
    the pipeline into seperate pickled files. The active and inactive
    files contain the data structure which holds a list of integer
    intervals with the key by Thread ID. This filter also intercepts
    the THREAD/NAME_THREAD event and changes the key from the Thread
    ID to the name of the thread which is inclded in the extra data of
    the NAME_THREAD event.     
    """
    
    expected_parameters = {
        "activity_outfile" : {
                           "types" : "string",
                           "doc"   : "The output file to which to send the filtered active thread intervals.",
                           "default" : "active_thread_intervals.dsui.tmp.bin"
                           },
        "inactivity_outfile" : {
                           "types" : "string",
                           "doc"   : "The output file to which to send the filtered inactive thread intervals.",
                           "default" : "inactive_thread_intervals.dsui.tmp.bin"
                           }
        }

    def initialize(self):
        """
        Name Space Pointer Reference:
        
        Pointer               |  DSTRM Instrumentation Location
        ---------------------------------------------------
        activity_period_ptr      Generated By CalculateThreadIntervalsFilter
        inactivity_period_ptr    Generated By CalculateThreadIntervalsFilter
        name_thread_ptr          userprog/systemcalls.cc
        """
        self.activity_period_ptr = self.get_ns_pointer("THREAD_ACTIVITY/ACTIVITY_PERIOD")
        self.inactivity_period_ptr = self.get_ns_pointer("THREAD_ACTIVITY/INACTIVITY_PERIOD")
        self.name_thread_ptr = self.get_ns_pointer("THREAD/NAME_THREAD")

        self.all_ptrs = [
                        self.activity_period_ptr,
                        self.inactivity_period_ptr,
                        self.name_thread_ptr
                        ]

        # For the thread_pid to thread_name mappings.
        self.thread_name_aliases = {}

        self.activity_intervals_by_thread = {}
        self.inactivity_intervals_by_thread = {}
        
    
    def process(self, entity):
        """
        Filter the events defined in initialize(). If the event is not
        filtered by this filter, it is sent back to the post
        processing pipeline. Otherwise, it seperates active and
        inactive intervals into two seperate dictionarys of intervals
        keyed by thread_id, or if it is a NAME_THREAD event it
        registers the Thread_Id to Thread_Name in the thread_name_aliases 
        dictionary.
        """
        cid = entity.get_cid()
        # If the cid does not match any of the pointers' cid in the
        # all_activity_ptrs list.
        if not any(cid == ptr.get_cid() for ptr in self.all_ptrs):
            # Then, pass the event back to the pipeline and exit the
            # function since it is not a pointer that is handled by
            # the filter.
            self.send(entity)
            return 

        # Get the Nachos thread id from the tag of the entity.
        thread_pid = entity.get_tag()
        
        if cid == self.name_thread_ptr.get_cid():
            # The event namespace pointer is NAME_THREAD so register
            # the name alias for the thread corresponding to
            # thread_pid.
            thread_name = entity.get_extra_data()
            self.thread_name_aliases[thread_pid] = thread_name 
            return 

        
        # The activity/inactivity intervals hold the start and end
        # times for the interval, so get the total duration of the
        # interval.
        interval_ticks = entity.get_duration('tsc')

        if cid == self.activity_period_ptr.get_cid():
            if not thread_pid in self.activity_intervals_by_thread.keys():
                # The key thread_pid does not exist yet, so initialize
                # it to an empty list.
                self.activity_intervals_by_thread[thread_pid] = []
            # Add the duration of the activity period to the list of
            # intervals for thread_pid.
            self.activity_intervals_by_thread[thread_pid].append(interval_ticks)
            return
        
        if cid == self.inactivity_period_ptr.get_cid():
            if not thread_pid in self.inactivity_intervals_by_thread.keys():
                # The key thread_pid does not exist yet, so initialize
                # it to an empty list.
                self.inactivity_intervals_by_thread[thread_pid] = []
            # Add the duration of the activity period to the list of
            # intervals for thread_pid.
            self.inactivity_intervals_by_thread[thread_pid].append(interval_ticks)
            return
        
            

    def finalize(self):
        """
        First:
        If there are thread_pid to thread_name aliases registered in
        the thread_name_alias dictionary, rekey the lists of intervals
        to use the thread_name instead of the thread_pid. 
        
        Secondly: 
        Pickle the activity and inactivity dictionaries and
        dump them to pickled files.
        """
        
        # Seach for each thread_pid in the keys of
        # activity_intervals_by_thread and see if there is a
        # thread_pid to thread_name mapping in the thread_name_aliases
        # dictionary. If there is re-key the active intervals
        # dictionary to use the thread_name instead of thread_pid.
        #
        for thread_pid in self.activity_intervals_by_thread.keys():
            if thread_pid in self.thread_name_aliases.keys():
                thread_name = self.thread_name_aliases[thread_pid]
                self.activity_intervals_by_thread[thread_name] = self.activity_intervals_by_thread[thread_pid]
                del self.activity_intervals_by_thread[thread_pid]

        # Seach for each thread_pid in the keys of
        # inactivity_intervals_by_thread and see if there is a
        # thread_pid to thread_name mapping in the thread_name_aliases
        # dictionary. If there is re-key the inactive intervals
        # dictionary to use the thread_name instead of thread_pid.
        #
        for thread_pid in self.inactivity_intervals_by_thread.keys():
            if thread_pid in self.thread_name_aliases.keys():
                thread_name = self.thread_name_aliases[thread_pid]
                self.inactivity_intervals_by_thread[thread_name] = self.inactivity_intervals_by_thread[thread_pid]
                del self.inactivity_intervals_by_thread[thread_pid]
                
        # Dump the dictionary that holds the key->value
        # (thread_id/thread_name -> list of intervals) into a pickled
        # files.
        #
        cPickle.dump(self.activity_intervals_by_thread,
                     open(self.params['activity_outfile'], 'w'))
        cPickle.dump(self.inactivity_intervals_by_thread,
                     open(self.params['inactivity_outfile'], 'w'))



